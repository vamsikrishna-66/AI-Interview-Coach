# -*- coding: utf-8 -*-
"""Q&A generation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cUcSq-5GX9LDuqAqR2DMaewYMgpoH5VE
"""

# cloud - 11

MODEL_ID = "gemini-2.0-flash" # @param ["gemini-1.5-flash-latest","gemini-2.0-flash-lite","gemini-2.0-flash","gemini-2.5-pro-exp-03-25"] {"allow-input":true, isTemplate: true}

# Commented out IPython magic to ensure Python compatibility.
# %pip install -U -q 'google-genai'
from google.colab import userdata
import sys

GOOGLE_API_KEY = "Insert your Gemini API Key here"

from google import genai
from google.genai import types

client = genai.Client(api_key=GOOGLE_API_KEY)



from IPython.display import Markdown

import time

def get_qa_pairs(content):
  response = client.models.generate_content(
      model=MODEL_ID,
      contents=content
  )

  return response

def format_job_description(jd):
    lines = []
    lines.append("--- JOB DESCRIPTION ---")

    # --- JOB TITLE ---
    lines.append("--- JOB TITLE ---")
    lines.append(jd.get("job_title", "N/A"))

    # --- COMPANY ---
    lines.append("\n--- COMPANY ---")
    lines.append(jd.get("company_name", "N/A"))
    if jd.get("company_url"):
        lines.append(f"Company URL: {jd['company_url']}")
    if jd.get("job_industries"):
        lines.append(f"Industry: {jd['job_industries']}")

    # --- LOCATION ---
    lines.append("\n--- LOCATION ---")
    lines.append(f"{jd.get('job_location', 'N/A')} (Country: {jd.get('country_code', 'N/A')})")

    # --- EMPLOYMENT DETAILS ---
    lines.append("\n--- EMPLOYMENT DETAILS ---")
    lines.append(f"Seniority Level: {jd.get('job_seniority_level', 'N/A')}")
    lines.append(f"Employment Type: {jd.get('job_employment_type', 'N/A')}")
    lines.append(f"Function: {jd.get('job_function', 'N/A')}")

    # --- JOB SUMMARY ---
    lines.append("\n--- JOB SUMMARY ---")
    job_summary = jd.get("job_summary", "").strip()
    if job_summary:
        lines.append(f"\n{job_summary}")

    # --- COMPENSATION ---
    salary = jd.get("base_salary", {})
    if salary:
      lines.append("\n--- COMPENSATION ---")
      min_salary = salary.get("min_amount")
      max_salary = salary.get("max_amount")
      currency = salary.get("currency", "$")
      if min_salary and max_salary:
          lines.append(f"Base Salary Range: {currency}{min_salary:,} - {currency}{max_salary:,} per year (USD)")
      if jd.get("job_base_pay_range"):
          lines.append(f"Range Stated: {jd['job_base_pay_range']}")
    lines.append("\n")

    return "\n".join(lines)


def format_education_section(education_list):
    if not education_list:
        return None
    lines = ["EDUCATION"]
    for edu in education_list:
        degree = edu.get("degree", "")
        field = edu.get("field", "")
        title = edu.get("title", "")
        location = edu.get("description", "")
        cgpa = edu.get("cgpa", "")
        start = edu.get("start_year", "")
        end = edu.get("end_year", "")
        line = f"{degree}, {field}".strip(", ")
        lines.append(line)
        lines.append(location or "")
        gpa_line = f"{title} (CGPA: {cgpa})" if cgpa else title
        lines.append(gpa_line)
        lines.append(f"{start}-{end}")
        coursework = edu.get("coursework")
        if coursework:
            lines.append(f"Coursework: {coursework}")
        lines.append("")
    return "\n".join(lines)

def format_experience_section(experience_list):
    if not experience_list:
        return None
    lines = ["EXPERIENCE"]
    for exp in experience_list:
        company = exp.get("company", "")
        title = exp.get("title", "")
        duration = f"{exp.get('start_date', '')} – {exp.get('end_date', '')}".strip(" –")
        lines.append(f"{company} | {title}")
        if duration:
            lines.append(duration)
        desc = exp.get("description", "")
        if desc:
            for bullet in desc.split("\n"):
                bullet = bullet.strip("• ").strip()
                if bullet:
                    lines.append(f"• {bullet}")
        lines.append("")
    return "\n".join(lines)

def format_projects_section(projects_list):
    if not projects_list:
        return None
    lines = ["PROJECTS AND PUBLICATIONS"]
    for proj in projects_list:
        title = proj.get("title", "").strip()
        if not title:
            continue
        tech = proj.get("tech_stack", "")
        duration = f"{proj.get('start_date', '')} – {proj.get('end_date', '')}".strip(" –")
        lines.append(f"{title} ({tech})")
        if duration:
            lines.append(duration)
        desc = proj.get("description", "")
        if desc:
            for bullet in desc.split("\n"):
                bullet = bullet.strip("• ").strip()
                if bullet:
                    lines.append(f"• {bullet}")
        lines.append("")
    return "\n".join(lines)

def format_skills_section(skills):
    if not skills:
        return None
    lines = ["SKILLS"]
    for k, v in skills.items():
        lines.append(f"{k}: {v}")
    lines.append("PROFESSIONAL")
    return "\n".join(lines)



def format_resume_fancy(resume):
    output = []
    output.append("\n")
    output.append("\n")
    output.append("\n---RESUME---")
    # NAME
    name = resume.get("name")
    if name:
        output.append("--- NAME ---")
        output.append(name.strip())

    # CONTACT
    contact_info = resume.get("contact")
    if contact_info:
        output.append("\n--- CONTACT ---")
        output.append(str(contact_info).strip())

    # EDUCATION
    education_section = format_education_section(resume.get("education"))
    if education_section:
        output.append("\n--- EDUCATION ---")
        output.append(education_section)

    # EXPERIENCE
    experience_section = format_experience_section(resume.get("experience"))
    if experience_section:
        output.append("\n--- EXPERIENCE ---")
        output.append(experience_section)

    # PROJECTS
    projects_section = format_projects_section(resume.get("projects"))
    if projects_section:
        output.append("\n--- PROJECTS ---")
        output.append(projects_section)

    # COURSES
    courses = resume.get("courses")
    if courses:
        output.append("\n--- COURSES ---")
        if isinstance(courses, list):
            output.extend([f"- {c.get('title', '')} ({c.get('subtitle', '')})" for c in courses if isinstance(c, dict) and c.get('title')])
        elif isinstance(courses, str):
            output.append(courses.strip())

    # CERTIFICATIONS
    certs = resume.get("certifications")
    if certs:
        output.append("\n--- CERTIFICATIONS ---")
        if isinstance(certs, list):
            output.extend([f"- {c}" for c in certs if isinstance(c, str) and c.strip()])
        elif isinstance(certs, str):
            output.append(certs.strip())

    # HONORS AND AWARDS
    honors = resume.get("honors_and_awards")
    if honors:
        output.append("\n--- HONORS AND AWARDS ---")
        if isinstance(honors, list):
            output.extend([f"- {h}" for h in honors if isinstance(h, str) and h.strip()])
        elif isinstance(honors, str):
            output.append(honors.strip())

    # PUBLICATIONS
    publications = resume.get("publications")
    if publications:
        output.append("\n--- PUBLICATIONS ---")
        if isinstance(publications, list):
            output.extend([f"- {p}" for p in publications if isinstance(p, str) and p.strip()])
        elif isinstance(publications, str):
            output.append(publications.strip())

    # SKILLS
    skills_section = format_skills_section(resume.get("skills"))
    if skills_section:
        output.append("\n--- SKILLS ---")
        output.append(skills_section)

    return "\n".join(output).strip()


def parse_question_blocks(text):
    # Normalize keys to avoid issues with quotes or underscores
    key_pattern = re.compile(r'"?(direct_question|direct_answer|followup_question|followup_answer|source|type)"?\s*:\s*["“](.*?)["”],?', re.IGNORECASE | re.DOTALL)
    matches = key_pattern.findall(text)

    blocks = []
    block = {}

    for key, value in matches:
        key = key.lower().strip()
        value = value.strip()
        block[key] = value

        # Once we reach 'type', we assume end of current Q&A block
        if key == 'type':
            if len(block) >= 4: blocks.append(block)
            block = {}

    return random.shuffle(blocks)

def parse_question_blocks(text):
    # Pre-clean possible backticks, newline escapes, and leading/trailing junk
    text = text.strip('` \n').replace('\\n', '\n')

    # Split blocks by curly braces (acts as crude JSON object separator)
    raw_blocks = re.findall(r'\{(.*?)\}', text, re.DOTALL)
    parsed_blocks = []

    for raw in raw_blocks:
        block = {}
        try:
            # Match key-value pairs inside each block
            pairs = re.findall(r'"(\w+)"\s*:\s*(null|"[^"]*?"|\d+)', raw, re.DOTALL)

            for key, val in pairs:
                key = key.strip().lower()

                # Handle types: remove quotes, convert null to None, try int
                if val == 'null':
                    value = None
                elif val.startswith('"') and val.endswith('"'):
                    value = val[1:-1].strip()
                elif val.isdigit():
                    value = int(val)
                else:
                    value = val

                block[key] = value

            # Only accept blocks with at least 4 valid keys
            if len(block) >= 4:
                parsed_blocks.append(block)
        except Exception as e:
            # Skip any block that throws a parsing error
            continue

    random.shuffle(parsed_blocks)
    return parsed_blocks

def parse_question_blocks(text):
  questions = []
  keys = ['direct_question', 'direct_answer', 'followup_question', 'followup_answer', 'source', 'type']
  for question in text.split("direct_question"):

    split = question.split('"')
    if len(split) < 10: continue
    temp = {}
    temp['direct_question'] = split[2]

    for index, sp in enumerate(split):
      if sp in keys:
        temp[sp] = split[index + 2]
    if len(temp) == 4 and temp['type'] != '1':
      temp['type'] = '1'

    questions.append(temp.copy())
  random.shuffle(questions)
  return questions

def json_to_text(blocks):
    result = []

    for block in blocks:
        try:
          lines = []

          lines.append(f"Direct Question: {block['direct_question']}")
          lines.append(f"Direct Answer: {block['direct_answer']}")
          if 'followup_question' in block and 'followup_answer' not in block:
              print("followup answer not found")
              continue
          if 'followup_question' in block and block['followup_question']:
              lines.append(f"Followup Question: {block['followup_question']}")
              lines.append(f"Followup Answer: {block['followup_answer']}")
          else:
              if block['type'] != '1':
                print(f"question of type {block['type']} dint generate followups")
              block['type'] = '1'
          lines.append(f"Source: {block['source']}")
          lines.append(f"Type: {block['type']}")

          result.append("\n".join(lines))
        except Exception as e:
          print(block)
          sys.exit(e)

    return "\n\n".join(result)

import os
import json
import pandas as pd


role = 'web'
jobs = f'/content/{role}_jobs.json'
resume = f'/content/{role}_resume.json'

jd_folder = '/content/drive/MyDrive/scraping_data/data_points/jay/jd'
resume_folder = '/content/drive/MyDrive/scraping_data/data_points/jay/resume'
final_data_point_folder = '/content/drive/MyDrive/scraping_data/data_points/jay/final'
final_json = '/content/drive/MyDrive/scraping_data/data_points/jay/final_json'
os.makedirs(final_json, exist_ok=True)

with open(jobs) as f:
  jobs = json.load(f)

with open(resume) as f:
  resumes = json.load(f)
  for resume in list(resumes):
    found = False
    if resume.get('experience'):
      for exp in resume.get('experience'):
        if 'description' in exp and exp['description']: found = True
    if resume.get('projects') and len(resume['projects']) != 0: found = True
    if not found: resumes.remove(resume)



import time
num_resumes = 3
difficulty_levels = ['easy', 'medium', 'hard']
prompt = """

generate questions and answers based on the job description and resume above. There should be two types of questions type
 that questions where was the question and the candidate will give you the answer type to follow questions. So you ask a question candidate will answer you for the question and you ask a follow-up question based on the previous question or based on the solution given by the candidate generate at least {0} questions ({1} type 1, {2} type 2, {3} type 3) based on Job Description and {4} questions ({5} type 1, {6} type 2, {7} type 3) based on resume you should give both question and answer in the Jason format (list of json along with keys for source - resume, jd, type - 1,2,3).
do not give very generic questions as this will be a technical interview, be very specific about job description requirements, resume content and what is overlapping between both JD and resume.

sample questions
{{
    "type": "1",
    "direct_question": "How much experience do you have in CICD? explain any project you worked on CICD.",
    "direct_answer": "candidate response....",
}}

{{
    "type": "2",
    "direct_question": "How much experience do you have in CICD? explain any project you worked on CICD.",
    "direct_answer": "candidate response....",
    "followup_question": "okay. so did you face any challanges while working on your project (or anything that the candidate mentions in his answer)?",
    "followup_answer": "candidate response for followup question...."
}}

{{
    "type": "3",
    "direct_question": "How much experience do you have in CICD? explain any project you worked on CICD.",
    "direct_answer": "candidate response....",
    "followup_question": "okay. explain what is branching in git? and when do we use it and when do we not use it?",
    "followup_answer": "candidate response for followup question...."
}}

Here observe in the second question, example the follow-up question is depending upon the answer given by the candidate for that question. But in the third sample, the follow-up question does not depend on the answer but depends on the direct question itself. So keep both of these types.


Note - do not ever use the words 'job description' in the question


question - generate question from interviewer perspective
answer - generate answer from candidate/interviewee perspective
always use same keys - direct_question, direct_answer, followup_question, followup_answer, source, type (source and type should be at the end) and all of type str

Answers should be complete and address the question completely, even if they are long. do not ever give incomplete or wrong answers.

difficuly level - {difficulty} (generate all questions based on the difficuly level)

VERY IMPORTANT - RESPOND ONLY IN JSON FORMAT, TYPE 2 AND TYPE 3 QUESTIONS MUST HAVE FOLLOWUP QUESTION AND ANSWER.

"""

import random
def get_num_questions():
  num_q_jd_type1 = random.choice([2, 3, 4, 5])
  num_q_jd_type2 = random.choice([2, 3, 4, 5])
  num_q_jd_type3 = random.choice([2, 3, 4, 5])
  num_q_resume_type1 = random.choice([2, 3, 4, 5])
  num_q_resume_type2 = random.choice([2, 3, 4, 5])
  num_q_resume_type3 = random.choice([2, 3, 4, 5])
  total_jd_questions = num_q_jd_type1 + num_q_jd_type2 + num_q_jd_type3
  total_resume_questions = num_q_resume_type1 + num_q_resume_type2 + num_q_resume_type3

  return total_jd_questions, num_q_jd_type1, num_q_jd_type2, num_q_jd_type3, total_resume_questions, num_q_resume_type1, num_q_resume_type2, num_q_resume_type3


for index, job in enumerate(jobs):
    if index < 10: continue

    with open(f"{jd_folder}/jd_{role}_{index}.json", "w") as f:
        # f.write(str(job))
        json.dump(job, f, indent=4)

    for resume_id in [index] + random.sample(range(0, len(resumes)), num_resumes - 1):

        resume = resumes[resume_id]

        with open(f"{resume_folder}/resume_{role}_{index}.json", "w") as f:
            # f.write(str(resume))
            json.dump(resume, f, indent=4)

        for difficulty in difficulty_levels:

          start_time = time.time()

          num_questions = get_num_questions()
          content = format_job_description(job) + format_resume_fancy(resume) + prompt.format(*num_questions, difficulty = difficulty)

          print("Generating qa from gemini...", end = '\r')
          response = get_qa_pairs(content)
          if not response.text:
            sys.exit(f"Response NONE: {response}, {response.text}")

          lines = []
          lines.append(content.split('generate questions and answers')[0])
          lines.append("")
          lines.append(f"Difficulty Level: {difficulty}")
          lines.append("")
          lines.append("\n")
          lines.append("---iINTERVIEW QUESTION ANSWERS---")
          lines.append("\n")
          lines.append("\n")

          with open(f"{final_json}/data_json_{role}_jd{index}_resume{resume_id}_{difficulty}.json", "w") as f:
            temp = {}
            temp['jd'] = job
            temp['resume'] = resume
            temp['qa_pairs'] = parse_question_blocks(response.text)

            if temp['qa_pairs'] == []:
              print(f"No questions generated for jd: {index}, resume: {resume_id}, difficulty: {difficulty}")
              continue
            json.dump(temp, f, indent=4)

          # Join all lines into a single string
          plain_text = "\n".join(lines) + json_to_text(temp['qa_pairs'])

          # Save to a .txt file
          with open(f"{final_data_point_folder}/data_{role}_jd{index}_resume{resume_id}_{difficulty}.txt", "w") as f:
              f.write(plain_text)
          end_time = time.time()
          time_taken = round(end_time - start_time, 2)
          print(f"Completed jd: {index}/{len(jobs)}, resume: {resume_id}, difficulty: {difficulty}, num_q: {len(temp['qa_pairs'])}, time: {time_taken}s")

len(os.listdir(final_data_point_folder))

